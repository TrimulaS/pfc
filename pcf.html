<!DOCTYPE html>
<html>
<head>
   <title>PCF</title>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
</head>

<!-- 
Resize 

area			|
c-tree			|
________________|

-->

<style>

	html, body {
		height: 100%;
		margin: 0;
		padding: 0;

		/* background-color:cornflowerblue;
		border-color:mediumspringgreen; */
	} 

	#pra {
		display: flex;
		justify-content: center;
		align-items: center;
		width: 100vw;
		height: 100vh;
	}

	#c-main {
		display: flex;
		width: calc(100% - 10px);
		height: calc(100% - 10px);
		margin: 5px;
		background-color: rgb(185, 253, 253);
	}

	#c-nodes {
		display: flex;
		flex-direction: column;
		/* width: 50%;  */
		height: 100%;
	}

	#c-tree, #c-prop {
		flex: 1;
		border: 1px solid red; /* Для отладки */
	}
	#c-tree {
		display: flex;
		flex-direction: column-reverse;
	}

	#c-tree p,
	#c-prop p,
	#c-log > p  {
		margin: 0;
		padding: 0;
	}

	#c-graph {
		/* flex: 1;
		border: 1px solid blue;  */
		width: 100%; /* Занимает 100% ширины родителя */
		height: 100%; /* Занимает 100% высоты родителя */
		display: block; /* Убирает пробелы под canvas */
	}

	.container{
		display: flex;
		box-sizing: border-box;
		border: solid 1px darkgreen;

	}
	.wrapper{
		display: flex;
		flex: 1;
	}

	.sidebar {
		display: flex;
		flex-direction: row; /* Вертикальная ориентация */
		gap: 5px;
		background-color:     #eee;; /* Цвет фона панели */
		padding: 2px; /* Внутренние отступы */
		border: 1px solid #ccc; /* Рамка панели */
		border-radius: 5px; /* Закругленные углы */
		box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Тень */
	}

	.button {
		padding: 5px ; /* Внутренние отступы кнопок */

		background-color: #007bff; /* Цвет фона кнопок */
		color: rgb(36, 44, 29); /* Цвет текста кнопок */
		border: none; /* Убираем рамку */
		border-radius: 5px; /* Закругленные углы кнопок */
		cursor: pointer; /* Указатель при наведении */
		transition: background-color 0.3s; /* Плавный переход цвета фона */
	}
	.flex-column{
		display: flex;
		flex-direction: column; 
	}
	.flex-row{
		display: flex;
		flex-direction: row; 
		width: 100%;


	}


</style>



<body>
	<script src = './js/shapes.js'>	</script>
	<script src = './js/split2.js'>	</script>
	<script src = './js/transform2D.js'>	</script>

	<div id = 'pra'  class="flex-column">
		<div class="flex-row">
			<label>
                <input type="checkbox" id="cb-UpdateList" checked="checked">Update List
				<input type="checkbox" id="cb-text-direction" checked="checked">Adopt text direction
            </label>

		</div>
		<div id = 'c-main' class="container">
			<div class="container">
				<div class="sidebar">
					
					<input type="number" id="numberOfShapes" value="100" min="0" max="10000" step="10" size="6">
					<button id = 'b-Generate' class="button">Generate</button>
					<button id = 'b-Reset' class="button">Reset</button>
					<button id = 'b-Center' class="button">Center</button>
					<button id = 'b-ReCreate' class="button">reCreate</button>
					<!-- <button class="button">Кнопка 3</button> -->
					<!-- <button class="button">Кнопка 4</button> -->
				</div>
				<div id = 'c-nodes' class="container">
					<div id = 'c-tree' class="container"></div>
					<div id = 'c-log' class="container"></div>
				</div>

			</div>



			<div> <!-- Extra div because splitter will add its own class -->
				<canvas id="c-graph" class="container"></canvas>
			</div>
		</div>
	</div>

	<script>

		// document.addEventListener('DOMContentLoaded', () => {
		// });
		
		const cMain = document.getElementById('c-main');
		const cbUpdateList = document.getElementById('cb-UpdateList');
		const cbTextDirection = document.getElementById('cb-text-direction');
		const cNodes = document.getElementById('c-nodes');
		const cTree = document.getElementById('c-tree');
		const cLog = document.getElementById('c-log');
		const cGraph = document.getElementById('c-graph');
		const inumberOfShapes = document.getElementById('numberOfShapes');


		new Split2().insertSplitter( cMain, 'row', 0.4);
		new Split2().insertSplitter( cNodes, 'column', 0.7);

		function rectToString(rect){
			return ` ${rect.left}  :   ${rect.top}  _    ${rect.width}  x  ${rect.height}`
		}

		// 1. Generate shape set
		let shapesNum
		let shapeSet
		let t 
		let xToPx
		let yToPy

		const ctx = cGraph.getContext('2d');

		function generate(){
			shapesNum = parseInt(inumberOfShapes.value);
			shapeSet = new ShapeSet(shapesNum , 60, 1000 , 30, 500)
			log('Shpes in set: ' + shapeSet.shapes.length)
			t = new Transform2D(cGraph, shapeSet.Xmin, shapeSet.Xmax, shapeSet.Ymin, shapeSet.Ymax);
			xToPx = t.xToPx.bind(t)			// Binding methods for convinience
		    yToPy = t.yToPy.bind(t)

			draw();

		}
		generate()
		log(`Boundaries ${shapeSet.Xmin} x ${shapeSet.Ymin} .. ${shapeSet.Xmax} x ${shapeSet.Ymax}`)

	
		
		//Processing
		shapeSet.shapes.forEach(element =>{
			//ta.textContent += element.toString()
			log(element.toString())
			//console.log(element.toString()+'------------ ')
		})





		
		

		
	




		function draw(){

			cGraph.width  = cGraph.clientWidth;
			cGraph.height = cGraph.clientHeight;


			if(cbUpdateList.checked)cTree.innerHTML=''
			ctx.clearRect(0, 0, cGraph.width, cGraph.height); // Очистка canvas
			

			shapeSet.shapes.forEach(s =>{
				// Skip tiny shapes
				if (s.width * t.k < 5 && s.height * t.k < 5) {
					return; 
				}
				// Skip shapes out of viwport
				const delta = 0						//for debug to see when shape disappeared
				if (
					s.left + s.width - delta >= t.visibleLeft &&
					s.left 	         + delta <= t.visibleRight &&
					s.top + s.height - delta>= t.visibleTop &&
					s.top 			 + delta<= t.visibleBottom
				) {

					// Drawing shape
					if(cbUpdateList.checked)addListItem(cTree, s.type + ' ' + s.id)

					ctx.fillStyle = s.color

					switch (s.type) {
						case 'rect':
							ctx.fillRect(xToPx(s.left), yToPy(s.top), s.width * t.k, s.height * t.k);
							break;
						case 'circle':
							ctx.beginPath();
							ctx.ellipse(
								xToPx(s.left + s.width / 2), // Центр X
								yToPy(s.top + s.height / 2), // Центр Y
								s.width * t.k / 2,             // Радиус по X
								s.height * t.k / 2,            // Радиус по Y
								0,                           // Угол поворота
								0,                           // Начальный угол
								Math.PI * 2                  // Конечный угол (полный круг)
							);
							ctx.fill();
							break;
						case 'line':
							ctx.beginPath();
							ctx.moveTo( xToPx( s.left ) , yToPy( s.top ) );
							ctx.lineTo( xToPx( s.left + s.width ) , yToPy( s.top + s.height ) );
							ctx.closePath();
							ctx.strokeStyle = s.color;
							ctx.stroke();
							break;
						case 'point':
							ctx.fillRect(xToPx(s.left), yToPy(s.top), 5, 5);
							break;
						default:
							console.log('(!) Wrong shape type')	
						    ctx.fillRect(xToPx(s.left), yToPy(s.top), 5, 5);
					}


					//ctx.strokeText()



						// === Рисуем ID фигуры по центру её видимой части ===

						// Инвертировать цвет (негатив)
						function invertColor(hex) {
							if (!hex || !/^#?[0-9A-Fa-f]{6}$/.test(hex)) return "black";
							if (hex[0] !== "#") hex = "#" + hex;
							const r = 255 - parseInt(hex.slice(1, 3), 16);
							const g = 255 - parseInt(hex.slice(3, 5), 16);
							const b = 255 - parseInt(hex.slice(5, 7), 16);
							return `rgb(${r},${g},${b})`;
						}

						// Видимая область фигуры
						const visibleLeft   = Math.max(s.left, t.visibleLeft);
						const visibleRight  = Math.min(s.left + s.width, t.visibleRight);
						const visibleTop    = Math.max(s.top, t.visibleTop);
						const visibleBottom = Math.min(s.top + s.height, t.visibleBottom);

						const visibleWidth  = visibleRight - visibleLeft;
						const visibleHeight = visibleBottom - visibleTop;

						const px = xToPx(visibleLeft + visibleWidth / 2);
						const py = yToPy(visibleTop + visibleHeight / 2);

						const text = s.id;
						ctx.textAlign = "center";
						ctx.textBaseline = "middle";
						ctx.fillStyle = invertColor(s.color || "#FFFFFF");

						// Настройки размеров шрифта
						const H_MIN = 6, H_MAX = 18;  // Горизонтально
						const V_MIN = 4, V_MAX = 14;  // Вертикально
						const STEP = 0.5;

						let found = false;

						// Сначала пробуем горизонтально
						for (let fontSize = H_MAX; fontSize >= H_MIN; fontSize -= STEP) {
							ctx.font = `${fontSize}px sans-serif`;
							const textWidth = ctx.measureText(text).width;
							const textHeight = fontSize;

							if (textWidth <= visibleWidth * t.k && textHeight <= visibleHeight * t.k) {
								ctx.fillText(text, px, py);
								found = true;
								break;
							}
						}

						// Если не влезло — пробуем вертикально
						if (!found) {
							for (let fontSize = V_MAX; fontSize >= V_MIN; fontSize -= STEP) {
								ctx.font = `${fontSize}px sans-serif`;
								const textWidth = ctx.measureText(text).width;
								const textHeight = fontSize;

								// В повороте местами ширина и высота
								if (textHeight <= visibleWidth * t.k && textWidth <= visibleHeight * t.k) {
									ctx.save();
									ctx.translate(px, py);
									ctx.rotate(-Math.PI / 2);
									ctx.fillText(text, 0, 0);
									ctx.restore();
									found = true;
									break;
								}
							}
						}




						
				}
			})

			// // Boundary rectangle
			// ctx.beginPath();
			// ctx.moveTo( xToPx( Xmin ) , yToPy( Ymin ) );
			// ctx.lineTo( xToPx( Xmin ) , yToPy( Ymax ) );
			// ctx.lineTo( xToPx( Xmax ) , yToPy( Ymax ) );
			// ctx.lineTo( xToPx( Xmax ) , yToPy( Ymin ) );
			// ctx.lineTo( xToPx( Xmin ) , yToPy( Ymin ) );
			// ctx.closePath();
			// ctx.strokeStyle = 'red';
			// ctx.stroke();

		}



		// Add listeners
		cGraph.addEventListener('mousedown', (e) => {
			t.mouseDown(e.clientX ,  e.clientY)
		});

		cGraph.addEventListener('mousemove', (e) => {
			if(t.isDragging ){
				t.mouseMove( e.clientX, e.clientY )
				draw();
			}
		});

		cGraph.addEventListener('mouseup', () => {
			t.isDragging = false;
		});

		cGraph.addEventListener('mouseleave', () => {
			t.isDragging = false;
		});

		// Добавляем событие для вращения колесика мыши
		cGraph.addEventListener('wheel', (e) => {
			t.mouseWheel(e.deltaY)
			draw();
			e.preventDefault();
		});

		// Resize canvas
		const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                // // Получаем новые размеры элемента
                // const { width, height } = entry.contentRect;
				// 	// ОБЯЗАТЕЛЬНО! Иначе canvas "сплющится" или "растянется"
				// cGraph.width = cGraph.clientWidth;
				// cGraph.height = cGraph.clientHeight;
				t.resize(cGraph.clientWidth, cGraph.clientHeight)
				draw()
                //console.log(`Размеры изменены: ширина = ${width}, высота = ${height}`);
            }
        });

        // Начинаем наблюдение за элементом
        resizeObserver.observe(cGraph);

		// window.addEventListener('resize', () => {
		// 	const w = cGraph.clientWidth
		// 	const h = cGraph.clientHeight

		// 	t.resize(w,h)
		// 	draw()
		// });



		


		// Loging
		function addListItem(domElement, text){

			const newParagraph = document.createElement('p');
			newParagraph.textContent = text;
			//console.log(text)

			domElement.appendChild(newParagraph);
			
		}
		function log(text){
			addListItem(cLog, text)
		}

		


		// Manage
		document.getElementById('b-Generate').addEventListener('click', function() {
				generate();
			});
		document.getElementById('b-Reset').addEventListener('click', function() {
				t.initScale();
				draw();
			});
		document.getElementById('b-Center').addEventListener('click', function() {
				t.centrlize()
				draw();

			});
		document.getElementById('b-ReCreate').addEventListener('click', function() {
			    // t = new Transform2D(cGraph, Xmin, Xmax, Ymin, Ymax);
				draw();
				//alert('Hello');
			});
	</script>

	

</body>
</html>

<!-- 
✓ Filtering shapes outside the viewport undesirable offset
✓ No mechanism fo do not process overlapped shapes -  not needed forthe moment (webGL)
make relative coordinates not depandant from scale

1. Adding shapes depicting tie periods

-->